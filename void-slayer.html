<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VOID-SLAYER | P2P Mesh MMORPG</title>
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <style>
        :root { --bg: #050508; --panel: #111116; --accent: #8b0000; --gold: #d4af37; --text: #aaa; --admin: #ff00ff; }
        body { background: var(--bg); color: var(--text); font-family: 'Crimson Text', serif; margin: 0; display: flex; height: 100vh; overflow: hidden; }
        nav { width: 220px; background: var(--panel); border-right: 1px solid #222; display: flex; flex-direction: column; padding: 20px; }
        .nav-link { color: #666; padding: 12px 10px; border-bottom: 1px solid #1a1a1a; cursor: pointer; transition: 0.2s; font-size: 0.95rem; }
        .nav-link:hover { color: #fff; background: #1a1a1f; padding-left: 15px; }
        main { flex: 1; display: flex; flex-direction: column; }
        #stats-bar { background: #000; padding: 15px 30px; border-bottom: 1px solid #222; display: flex; gap: 40px; font-family: monospace; font-size: 0.9rem; align-items: center; }
        .stat-val { color: var(--gold); font-weight: bold; }
        .content { flex: 1; padding: 40px; overflow-y: auto; background: radial-gradient(circle at top, #16161d 0%, #050508 100%); }
        .card { background: rgba(20, 20, 25, 0.98); border: 1px solid #333; padding: 25px; margin-bottom: 20px; }
        .action-btn { background: #222; border: 1px solid #444; color: #ccc; padding: 12px 24px; cursor: pointer; text-transform: uppercase; margin: 5px; font-family: inherit; }
        .action-btn:hover { background: var(--accent); color: white; border-color: red; }
        #game-log { height: 160px; overflow-y: auto; border-top: 1px solid #222; padding-top: 10px; font-size: 0.85rem; color: #888; margin-top: 20px; }
        #auth-screen { position: fixed; inset: 0; background: #000; z-index: 1000; display: flex; align-items: center; justify-content: center; flex-direction: column; }
        input, select { background: #111; border: 1px solid #333; color: white; padding: 12px; margin-bottom: 12px; width: 260px; box-sizing: border-box; }
        .hidden { display: none; }
        .debug { font-size: 0.75rem; color: #555; margin-top: 10px; font-family: monospace; }

        /* Auth form styles */
        .auth-card { background: rgba(20, 20, 25, 0.98); border: 1px solid #333; padding: 30px 40px; display: flex; flex-direction: column; align-items: center; max-width: 400px; width: 100%; }
        .auth-tabs { display: flex; gap: 0; margin-bottom: 20px; width: 100%; }
        .auth-tab { flex: 1; padding: 12px; text-align: center; cursor: pointer; background: #111; border: 1px solid #333; color: #666; text-transform: uppercase; font-family: inherit; letter-spacing: 2px; font-size: 0.85rem; transition: 0.2s; }
        .auth-tab.active { background: var(--accent); color: white; border-color: var(--accent); }
        .auth-tab:hover:not(.active) { color: #fff; background: #1a1a1f; }
        .auth-error { color: #ff4444; font-size: 0.85rem; margin-bottom: 10px; min-height: 1.2em; text-align: center; }
        .auth-success { color: #44ff44; font-size: 0.85rem; margin-bottom: 10px; min-height: 1.2em; text-align: center; }
        .auth-field { width: 100%; }
        .auth-field label { display: block; color: #888; font-size: 0.8rem; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 1px; }
        .auth-field input, .auth-field select { width: 100%; }
        .auth-divider { width: 100%; border-top: 1px solid #222; margin: 15px 0; position: relative; }
        .auth-divider span { position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: rgba(20, 20, 25, 0.98); padding: 0 10px; color: #555; font-size: 0.8rem; }
        .realm-info { font-size: 0.75rem; color: #555; text-align: center; margin-top: -5px; margin-bottom: 10px; }
        .name-link { color: inherit; cursor: pointer; text-decoration: none; border-bottom: 1px dotted #555; transition: 0.15s; }
        .name-link:hover { color: var(--gold); border-bottom-color: var(--gold); }
    </style>
</head>
<body>

<div id="auth-screen">
    <h1 style="color:var(--accent); letter-spacing: 5px; margin-bottom: 5px;">VOID-SLAYER</h1>
    <p style="color: #555; margin-top: 0; margin-bottom: 25px; font-size: 0.9rem;">P2P Mesh MMORPG</p>

    <div class="auth-card">
        <div class="auth-tabs">
            <div class="auth-tab active" id="tab-login-btn" onclick="switchAuthTab('login')">Login</div>
            <div class="auth-tab" id="tab-register-btn" onclick="switchAuthTab('register')">Register</div>
        </div>

        <div id="auth-error" class="auth-error"></div>
        <div id="auth-success" class="auth-success"></div>

        <!-- Login Form -->
        <div id="auth-login">
            <div class="auth-field">
                <label>Username</label>
                <input type="text" id="login-username" placeholder="Enter username" onkeypress="if(event.key==='Enter')doLogin()">
            </div>
            <div class="auth-field">
                <label>Password</label>
                <input type="password" id="login-password" placeholder="Enter password" onkeypress="if(event.key==='Enter')doLogin()">
            </div>
            <button class="action-btn" style="width:100%; margin: 10px 0 0 0;" onclick="doLogin()">Enter the Void</button>
        </div>

        <!-- Register Form -->
        <div id="auth-register" class="hidden">
            <div class="auth-field">
                <label>Username</label>
                <input type="text" id="reg-username" placeholder="Choose a username" onkeypress="if(event.key==='Enter')doRegister()">
            </div>
            <div class="auth-field">
                <label>Password</label>
                <input type="password" id="reg-password" placeholder="Choose a password" onkeypress="if(event.key==='Enter')doRegister()">
            </div>
            <div class="auth-field">
                <label>Confirm Password</label>
                <input type="password" id="reg-password2" placeholder="Confirm password" onkeypress="if(event.key==='Enter')doRegister()">
            </div>
            <div class="auth-field">
                <label>Race</label>
                <select id="race-sel" style="width:100%;">
                    <option value="Hollow">Hollow (+Str)</option>
                    <option value="Wraith">Wraith (+Wis)</option>
                </select>
            </div>
            <button class="action-btn" style="width:100%; margin: 10px 0 0 0;" onclick="doRegister()">Create Character</button>
        </div>

        <div class="auth-divider"><span>REALM</span></div>

        <div class="auth-field">
            <input type="text" id="realm-name" value="void-realm-default" placeholder="Realm name" style="text-align:center; font-family: monospace; color: var(--gold); border-color: #444;">
        </div>
        <div class="realm-info">Players in the same realm auto-connect. Change this to create a private realm.</div>

        <div class="debug" id="connection-status">Initializing...</div>
    </div>
</div>

<nav>
    <h2 style="color:var(--accent)">VOID MENU</h2>
    <div class="nav-link" onclick="showTab('grind')">The Frontier</div>
    <div id="nav-dungeon" class="nav-link" onclick="showTab('dungeon')">The Void Gate</div>
    <div class="nav-link" onclick="showTab('lead'); loadLeaderboard();">Leaderboard</div>
    <div class="nav-link" onclick="showTab('shop'); refreshShop();">Black Market</div>
    <div class="nav-link" onclick="showTab('pvp'); refreshPvpTargets();">The Arena</div>
    <div class="nav-link" onclick="showTab('guild'); refreshGuildUI();">Guild Hall</div>
    <div class="nav-link" onclick="showTab('chat')">Tavern</div>
    <div class="debug" style="margin-top: auto; padding-top: 20px;">
        <div id="peer-count">Mesh Peers: 0</div>
        <div id="player-count">Players: 0</div>
        <div id="sync-status">‚ö´ Not connected</div>
    </div>
</nav>

<main>
    <div id="stats-bar">
        <span>LVL: <span id="s-lvl" class="stat-val">1</span></span>
        <span>HP: <span id="s-hp" class="stat-val">100/100</span></span>
        <span>GOLD: <span id="s-gold" class="stat-val">0</span></span>
        <span>NAME: <span id="s-name" class="stat-val" style="cursor:pointer; border-bottom:1px dotted var(--gold);" onclick="viewProfile(currentUser)">---</span></span>
    </div>
    <div id="pvp-notification" style="display:none; background:#330000; padding:10px 30px; border-bottom:1px solid #660000; font-size:0.9rem; cursor:pointer; justify-content:space-between; align-items:center;" onclick="showTab('pvp'); refreshPvpTargets(); dismissNotification();">
        <span id="pvp-notif-text" style="color:#ff6666;"></span>
        <span style="color:#666; font-size:0.75rem;">CLICK TO VIEW</span>
    </div>

    <div class="content">
        <div id="admin-controls" class="hidden card" style="border: 2px dashed var(--admin);">
            <h4 style="color:var(--admin); margin:0 0 10px 0;">ADMIN: VOID MASTER</h4>
            <button class="action-btn" onclick="spawnBoss()">SPAWN BOSS</button>
            <button class="action-btn" onclick="closeBoss()">CLOSE GATE</button>
        </div>

        <section id="tab-grind">
            <div class="card">
                <h3 style="color:var(--accent); margin-top:0;">The Frontier</h3>
                <button class="action-btn" onclick="grind()">Slay Creature</button>
                <button class="action-btn" onclick="rest()">Rest</button>
            </div>
            <div id="game-log"></div>
        </section>

        <section id="tab-lead" class="hidden">
            <div class="card">
                <h3>Hall of Souls</h3>
                <button class="action-btn" onclick="loadLeaderboard()" style="margin-bottom:15px;">üîÑ Refresh</button>
                <div id="my-rank" style="color:var(--gold); margin-bottom:15px; font-weight:bold;">Your rank: --</div>
                <div id="leaderboard-list"></div>
                <div class="debug" id="lb-debug"></div>
            </div>
        </section>

        <section id="tab-shop" class="hidden"><div class="card"><h3>Black Market</h3><div id="shop-items"></div></div></section>
        <section id="tab-dungeon" class="hidden">
            <div class="card">
                <h3>Void Gate</h3>
                <p id="d-desc">The gate is currently sealed.</p>
                <div id="boss-ui" class="hidden">
                    <button class="action-btn" style="border-color:var(--admin)" onclick="fightBoss()">Fight Horror</button>
                </div>
            </div>
        </section>
        <section id="tab-chat" class="hidden">
            <div class="card">
                <h3>The Tavern</h3>
                <div id="chat-box" style="height:200px; overflow-y:auto; background:#000; padding:10px; margin-bottom:10px;"></div>
                <input id="chat-in" style="width:70%;" onkeypress="if(event.key==='Enter')sendChat()">
                <button class="action-btn" onclick="sendChat()">Send</button>
            </div>
        </section>
        <section id="tab-pvp" class="hidden">
            <div class="card">
                <h3 style="color:var(--accent); margin-top:0;">The Arena</h3>
                <p style="color:#888; font-size:0.9rem;">Challenge other players to steal their gold. Higher level opponents yield more XP. <span id="war-bonus-hint" style="color:#ff8800; display:none;">‚öîÔ∏è Guild war attacks earn WAR POINTS!</span></p>
                <button class="action-btn" onclick="refreshPvpTargets()" style="margin-bottom:15px;">üîÑ Refresh Targets</button>
                <div id="pvp-targets"></div>
            </div>
            <div class="card">
                <h3 style="color:#cc4444; margin-top:0;">Combat Log</h3>
                <div id="pvp-log" style="max-height:200px; overflow-y:auto; font-size:0.85rem;"></div>
            </div>
        </section>
        <section id="tab-guild" class="hidden">
            <!-- No Guild View -->
            <div id="guild-no-guild">
                <div class="card">
                    <h3 style="color:var(--accent); margin-top:0;">Guild Hall</h3>
                    <p style="color:#888;">You are not in a guild. Create one or join an existing guild.</p>
                    <div style="margin-top:15px;">
                        <h4 style="color:var(--gold); margin-bottom:10px;">Create a Guild</h4>
                        <input type="text" id="guild-create-name" placeholder="Guild name" style="width:200px;">
                        <button class="action-btn" onclick="createGuild()">Found Guild (500g)</button>
                    </div>
                    <div style="margin-top:20px;">
                        <h4 style="color:var(--gold); margin-bottom:10px;">Available Guilds</h4>
                        <div id="guild-available-list"></div>
                    </div>
                </div>
            </div>
            <!-- In Guild View -->
            <div id="guild-my-guild" class="hidden">
                <div class="card">
                    <h3 style="color:var(--accent); margin-top:0;">‚öîÔ∏è <span id="guild-name-display"></span></h3>
                    <div id="guild-leader-controls" class="hidden" style="margin-bottom:15px; padding:10px; border:1px dashed var(--gold); background:rgba(212,175,55,0.05);">
                        <span style="color:var(--gold); font-size:0.85rem;">üëë GUILD LEADER</span>
                        <button class="action-btn" onclick="disbandGuild()" style="margin-left:10px; border-color:#660000;">Disband</button>
                    </div>
                    <button class="action-btn" onclick="leaveGuild()" style="border-color:#666;">Leave Guild</button>
                    <button class="action-btn" onclick="refreshGuildUI()">üîÑ Refresh</button>
                    <h4 style="color:#888; margin-top:20px;">Members</h4>
                    <div id="guild-member-list"></div>
                </div>
                <div class="card">
                    <h3 style="color:#ff8800; margin-top:0;">‚öîÔ∏è Guild Wars</h3>
                    <div id="guild-war-controls" class="hidden" style="margin-bottom:15px;">
                        <h4 style="color:var(--gold); margin-bottom:10px;">Declare War</h4>
                        <div id="guild-war-target-list"></div>
                    </div>
                    <h4 style="color:#888;">Active Wars</h4>
                    <div id="guild-active-wars"><span style="color:#666;">No active wars</span></div>
                    <h4 style="color:#888; margin-top:15px;">War History</h4>
                    <div id="guild-war-history"><span style="color:#666;">No past wars</span></div>
                </div>
            </div>
        </section>
        <section id="tab-profile" class="hidden">
            <div id="profile-content"></div>
        </section>
    </div>
</main>

<script>
    const ADMIN = "boyo1991";
    
    const tabChannel = new BroadcastChannel('void-slayer-tabs');
    
    let peer = null;
    let myPeerId = null;
    let connections = new Map();
    let currentUser = null;
    let p = { lvl:1, xp:0, gold:0, hp:100, mhp:100, str:10, wis:10, race:'Hollow', weap:'None', guild:null, blurb:'', avatar:'üíÄ' };
    let seenChatIds = new Set();
    let gameState = {
        players: {},
        guilds: {},   // { guildName: { leader, members: [], created } }
        wars: [],     // [{ id, attacker, defender, scores: {att:0, def:0}, goal:10, started, ended, winner }]
        gate: 'CLOSED',
        chat: []
    };

    // ‚îÄ‚îÄ‚îÄ AUTH SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // In-memory account store (synced via mesh, no localStorage)
    let accountsStore = {};

    async function hashPassword(password) {
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function getAccounts() {
        return accountsStore;
    }

    function saveAccounts(accounts) {
        accountsStore = accounts;
    }

    function switchAuthTab(tab) {
        document.getElementById('auth-error').innerText = '';
        document.getElementById('auth-success').innerText = '';
        
        if (tab === 'login') {
            document.getElementById('auth-login').classList.remove('hidden');
            document.getElementById('auth-register').classList.add('hidden');
            document.getElementById('tab-login-btn').classList.add('active');
            document.getElementById('tab-register-btn').classList.remove('active');
        } else {
            document.getElementById('auth-login').classList.add('hidden');
            document.getElementById('auth-register').classList.remove('hidden');
            document.getElementById('tab-login-btn').classList.remove('active');
            document.getElementById('tab-register-btn').classList.add('active');
        }
    }

    async function doRegister() {
        const username = document.getElementById('reg-username').value.trim();
        const password = document.getElementById('reg-password').value;
        const password2 = document.getElementById('reg-password2').value;
        const race = document.getElementById('race-sel').value;
        const errorEl = document.getElementById('auth-error');
        const successEl = document.getElementById('auth-success');
        
        errorEl.innerText = '';
        successEl.innerText = '';

        if (!username || username.length < 2) {
            errorEl.innerText = 'Username must be at least 2 characters.';
            return;
        }
        if (username.length > 20) {
            errorEl.innerText = 'Username must be 20 characters or less.';
            return;
        }
        if (!password || password.length < 4) {
            errorEl.innerText = 'Password must be at least 4 characters.';
            return;
        }
        if (password !== password2) {
            errorEl.innerText = 'Passwords do not match.';
            return;
        }

        const accounts = getAccounts();
        if (accounts[username.toLowerCase()]) {
            errorEl.innerText = 'That username is already taken.';
            return;
        }

        const hash = await hashPassword(password);
        accounts[username.toLowerCase()] = {
            displayName: username,
            hash: hash,
            race: race,
            created: Date.now()
        };
        saveAccounts(accounts);

        broadcastToMesh({ type: 'ACCOUNT_SYNC', accounts: accounts });

        successEl.innerText = 'Account created! You can now log in.';
        
        setTimeout(() => {
            switchAuthTab('login');
            document.getElementById('login-username').value = username;
            document.getElementById('login-password').focus();
        }, 1000);
    }

    async function doLogin() {
        const username = document.getElementById('login-username').value.trim();
        const password = document.getElementById('login-password').value;
        const errorEl = document.getElementById('auth-error');
        
        errorEl.innerText = '';

        if (!username || !password) {
            errorEl.innerText = 'Please enter username and password.';
            return;
        }

        const accounts = getAccounts();
        const account = accounts[username.toLowerCase()];
        
        if (!account) {
            errorEl.innerText = 'Account not found. Register first!';
            return;
        }

        const hash = await hashPassword(password);
        if (hash !== account.hash) {
            errorEl.innerText = 'Incorrect password.';
            return;
        }

        currentUser = account.displayName;
        document.getElementById('auth-screen').style.display = 'none';
        document.getElementById('s-name').innerText = currentUser;
        
        if (currentUser === ADMIN) {
            document.getElementById('admin-controls').classList.remove('hidden');
        }

        initPlayer(account.race);
    }

    // ‚îÄ‚îÄ‚îÄ PEER MESH SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function getRealmName() {
        return document.getElementById('realm-name').value.trim() || 'void-realm-default';
    }

    function realmBeaconId(realm) {
        let hash = 0;
        const str = 'VS-' + realm;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return 'vs-realm-' + Math.abs(hash).toString(36);
    }

    function initMesh() {
        const realm = getRealmName();
        const beaconId = realmBeaconId(realm);
        
        peer = new Peer(beaconId);
        
        peer.on('open', (id) => {
            myPeerId = id;
            document.getElementById('connection-status').innerText = `Connected to realm: ${realm}`;
            console.log('üåê I am the realm beacon:', id);
            
            addPeerToMesh(id);
            connectToKnownPeers();
        });
        
        peer.on('error', (err) => {
            if (err.type === 'unavailable-id') {
                console.log('üîó Beacon exists, joining as regular peer...');
                peer = new Peer();
                
                peer.on('open', (id) => {
                    myPeerId = id;
                    document.getElementById('connection-status').innerText = `Connected to realm: ${realm}`;
                    console.log('üåê My Peer ID:', id);
                    
                    addPeerToMesh(id);
                    connectToPeer(beaconId);
                    connectToKnownPeers();
                });
                
                peer.on('connection', (conn) => {
                    console.log('üì• Incoming connection from:', conn.peer);
                    setupConnection(conn);
                });
                
                peer.on('error', (err2) => {
                    console.error('‚ùå Peer error:', err2);
                    document.getElementById('connection-status').innerText = `‚ö† Connection issue (still playable)`;
                });
            } else {
                console.error('‚ùå Peer error:', err);
                document.getElementById('connection-status').innerText = `‚ö† Connection issue (still playable)`;
            }
        });
        
        peer.on('connection', (conn) => {
            console.log('üì• Incoming connection from:', conn.peer);
            setupConnection(conn);
        });
    }

    let knownPeersStore = []; // In-memory peer list

    function addPeerToMesh(peerId) {
        if (!knownPeersStore.includes(peerId)) {
            knownPeersStore.push(peerId);
            tabChannel.postMessage({ type: 'NEW_PEER', peerId });
        }
    }

    function connectToKnownPeers() {
        console.log('üîç Known peers:', knownPeersStore);
        
        knownPeersStore.forEach(peerId => {
            if (peerId !== myPeerId && !connections.has(peerId)) {
                connectToPeer(peerId);
            }
        });
    }

    function connectToPeer(peerId) {
        if (connections.has(peerId) || peerId === myPeerId) return;
        
        console.log('üîó Connecting to peer:', peerId);
        const conn = peer.connect(peerId);
        setupConnection(conn);
    }

    function setupConnection(conn) {
        connections.set(conn.peer, conn);
        addPeerToMesh(conn.peer);
        updatePeerCount();
        
        conn.on('open', () => {
            console.log('‚úÖ Connected to:', conn.peer);
            document.getElementById('sync-status').innerHTML = 'üü¢ Mesh Connected';
            
            conn.send({
                type: 'FULL_SYNC',
                state: gameState,
                accounts: getAccounts()
            });
        });
        
        conn.on('data', (data) => {
            handleMeshMessage(data, conn);
        });
        
        conn.on('close', () => {
            console.log('üëã Peer disconnected:', conn.peer);
            connections.delete(conn.peer);
            updatePeerCount();
            if (connections.size === 0) {
                document.getElementById('sync-status').innerHTML = '‚ö´ No peers';
            }
        });
        
        conn.on('error', (err) => {
            console.error('‚ùå Connection error:', err);
            connections.delete(conn.peer);
        });
    }

    function handleMeshMessage(data, conn) {
        console.log('üì® Received:', data.type, 'from', conn.peer);
        
        switch(data.type) {
            case 'FULL_SYNC':
                mergeGameState(data.state);
                if (data.accounts) mergeAccounts(data.accounts);
                break;
                
            case 'PLAYER_UPDATE':
                gameState.players[data.player] = data.data;
                saveGameState();
                broadcastToTabs('PLAYER_UPDATE');
                broadcastToMesh({ type: 'PLAYER_UPDATE', player: data.player, data: data.data }, conn.peer);
                updateLeaderboardDisplay();
                break;
                
            case 'GATE_UPDATE':
                gameState.gate = data.state;
                saveGameState();
                updateGateUI(data.state);
                broadcastToTabs('GATE_UPDATE', data.state);
                broadcastToMesh(data, conn.peer);
                break;
                
            case 'CHAT_MESSAGE':
                if (!seenChatIds.has(data.msg.id)) {
                    seenChatIds.add(data.msg.id);
                    gameState.chat.push(data.msg);
                    if (gameState.chat.length > 100) gameState.chat.shift();
                    saveGameState();
                    displayChat(data.msg);
                    broadcastToTabs('CHAT_MESSAGE', data.msg);
                    broadcastToMesh(data, conn.peer);
                }
                break;

            case 'ACCOUNT_SYNC':
                if (data.accounts) mergeAccounts(data.accounts);
                break;

            case 'PVP_ATTACK':
                handlePvpNotification(data);
                broadcastToTabs('PVP_ATTACK', data);
                broadcastToMesh(data, conn.peer);
                break;

            case 'GUILD_UPDATE':
                gameState.guilds = data.guilds;
                saveGameState();
                broadcastToTabs('GUILD_UPDATE');
                broadcastToMesh(data, conn.peer);
                break;

            case 'WAR_UPDATE':
                gameState.wars = data.wars;
                saveGameState();
                broadcastToTabs('WAR_UPDATE');
                broadcastToMesh(data, conn.peer);
                break;
        }
    }

    function mergeAccounts(incoming) {
        const local = getAccounts();
        let changed = false;
        
        Object.keys(incoming).forEach(key => {
            if (!local[key]) {
                local[key] = incoming[key];
                changed = true;
            }
        });
        
        if (changed) {
            saveAccounts(local);
        }
    }

    function mergeGameState(incomingState) {
        Object.keys(incomingState.players).forEach(name => {
            const incoming = incomingState.players[name];
            const existing = gameState.players[name];
            
            if (!existing || incoming.lastSeen > existing.lastSeen) {
                gameState.players[name] = incoming;
            }
        });
        
        incomingState.chat.forEach(msg => {
            if (!seenChatIds.has(msg.id)) {
                seenChatIds.add(msg.id);
                gameState.chat.push(msg);
                displayChat(msg);
            }
        });
        if (gameState.chat.length > 100) {
            gameState.chat = gameState.chat.slice(-100);
        }
        
        if (!gameState.gate) {
            gameState.gate = incomingState.gate || 'CLOSED';
        }

        // Merge guilds
        if (incomingState.guilds) {
            if (!gameState.guilds) gameState.guilds = {};
            Object.keys(incomingState.guilds).forEach(name => {
                if (!gameState.guilds[name]) {
                    gameState.guilds[name] = incomingState.guilds[name];
                } else {
                    const inc = incomingState.guilds[name];
                    const loc = gameState.guilds[name];
                    if (inc.members.length > loc.members.length) {
                        gameState.guilds[name] = inc;
                    }
                }
            });
            // Remove guilds that were disbanded (exist locally but not in incoming with more data)
            Object.keys(gameState.guilds).forEach(name => {
                if (!incomingState.guilds[name] && Object.keys(incomingState.guilds).length > 0) {
                    // Only delete if incoming has guilds but this one is missing ‚Äî it was disbanded
                }
            });
        }

        // Merge wars
        if (incomingState.wars && incomingState.wars.length > 0) {
            if (!gameState.wars) gameState.wars = [];
            incomingState.wars.forEach(incWar => {
                const existing = gameState.wars.find(w => w.id === incWar.id);
                if (!existing) {
                    gameState.wars.push(incWar);
                } else {
                    const incTotal = (incWar.scores?.att || 0) + (incWar.scores?.def || 0);
                    const exTotal = (existing.scores?.att || 0) + (existing.scores?.def || 0);
                    if (incTotal > exTotal || incWar.ended) {
                        Object.assign(existing, incWar);
                    }
                }
            });
        }
        
        saveGameState();
        updateLeaderboardDisplay();
        updateGateUI(gameState.gate);
        console.log('üîÑ Merged game state');
    }

    function broadcastToMesh(message, exceptPeerId = null) {
        connections.forEach((conn, peerId) => {
            if (peerId !== exceptPeerId && conn.open) {
                conn.send(message);
            }
        });
    }

    function broadcastToTabs(type, data = null) {
        tabChannel.postMessage({ type, data });
    }

    tabChannel.onmessage = (event) => {
        const { type, data, peerId } = event.data;
        
        switch(type) {
            case 'PLAYER_UPDATE':
                updateLeaderboardDisplay();
                break;
            case 'GATE_UPDATE':
                updateGateUI(data);
                break;
            case 'CHAT_MESSAGE':
                if (!seenChatIds.has(data.id)) {
                    seenChatIds.add(data.id);
                    displayChat(data);
                }
                break;
            case 'NEW_PEER':
                if (peer && peerId !== myPeerId && !connections.has(peerId)) {
                    connectToPeer(peerId);
                }
                break;
            case 'PVP_ATTACK':
                handlePvpNotification(data);
                break;
            case 'GUILD_UPDATE':
                if (data) gameState.guilds = data;
                break;
            case 'WAR_UPDATE':
                if (data) gameState.wars = data;
                break;
        }
    };

    // ‚îÄ‚îÄ‚îÄ GAME STATE (IN-MEMORY) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // No localStorage ‚Äî state lives in memory and syncs via mesh.
    // saveGameState is kept as a function name for compatibility but does nothing to disk.
    function saveGameState() {
        // In-memory only ‚Äî state is already in the gameState variable.
        // Peers receive updates via broadcastToMesh calls.
    }

    function loadGameState() {
        // No-op ‚Äî fresh state each session. Peers will FULL_SYNC on connect.
        if (!gameState.guilds) gameState.guilds = {};
        if (!gameState.wars) gameState.wars = [];
    }

    function updatePeerCount() {
        document.getElementById('peer-count').innerText = `Mesh Peers: ${connections.size}`;
    }

    // ‚îÄ‚îÄ‚îÄ INITIALIZE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    loadGameState();
    initMesh();

    // ‚îÄ‚îÄ‚îÄ GAME LOGIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function initPlayer(race) {
        console.log('üéÆ Initializing player:', currentUser);
        
        if (gameState.players[currentUser]) {
            console.log('üì¶ Loading saved player');
            Object.assign(p, gameState.players[currentUser]);
        } else {
            console.log('‚ú® Creating new player');
            p.race = race || 'Hollow';
            p.str = p.race === 'Hollow' ? 15 : 10;
            p.wis = p.race === 'Wraith' ? 15 : 10;
        }
        
        refreshUI();
        save();
        
        gameState.chat.forEach(msg => displayChat(msg));
        updateGateUI(gameState.gate);
        
        sendSystemChat(`${currentUser} has entered the realm!`);
        
        setInterval(() => { save(); }, 2000);
        
        updateLeaderboardDisplay();
        updatePlayerCount();
    }

    function save() {
        const playerData = {
            name: currentUser,
            lvl: Number(p.lvl),
            gold: Number(p.gold),
            hp: Number(p.hp),
            mhp: Number(p.mhp),
            str: Number(p.str),
            wis: Number(p.wis),
            race: p.race,
            weap: p.weap,
            guild: p.guild,
            blurb: p.blurb || '',
            avatar: p.avatar || 'üíÄ',
            lastSeen: Date.now()
        };
        
        gameState.players[currentUser] = playerData;
        saveGameState();
        
        broadcastToMesh({ type: 'PLAYER_UPDATE', player: currentUser, data: playerData });
        broadcastToTabs('PLAYER_UPDATE');
    }

    function updatePlayerCount() {
        document.getElementById('player-count').innerText = `Players: ${Object.keys(gameState.players).length}`;
    }

    function updateGateUI(gateState) {
        const desc = document.getElementById('d-desc');
        const bossUI = document.getElementById('boss-ui');
        
        if (gateState === "OPEN") {
            desc.innerHTML = '<span style="color:var(--admin)">‚ö° THE VOID GATE IS OPEN! ‚ö°</span><br>A Horror from beyond awaits...';
            bossUI.classList.remove('hidden');
        } else {
            desc.innerText = 'The gate is currently sealed.';
            bossUI.classList.add('hidden');
        }
    }

    function displayChat(msg) {
        if (!msg || !msg.text || !msg.from) return;
        
        const box = document.getElementById('chat-box');
        const time = new Date(msg.time).toLocaleTimeString();
        const isSystem = msg.from === 'SYSTEM';
        const color = isSystem ? 'var(--admin)' : (msg.from === currentUser ? 'var(--gold)' : '#fff');
        
        let prefixHtml;
        if (isSystem) {
            prefixHtml = `<b style="color:${color}">[SYSTEM]</b>`;
        } else {
            const escaped = msg.from.replace(/'/g, "\\'");
            const pl = gameState.players[msg.from];
            const av = pl && pl.avatar ? pl.avatar : 'üíÄ';
            prefixHtml = `<span class="name-link" style="color:${color}" onclick="viewProfile('${escaped}')">${av} <b>[${msg.from}]</b></span>`;
        }
        
        const msgDiv = document.createElement('div');
        msgDiv.innerHTML = `<span style="color:#666">${time}</span> ${prefixHtml} ${msg.text}`;
        box.appendChild(msgDiv);
        box.scrollTop = box.scrollHeight;
        
        while (box.children.length > 50) {
            box.removeChild(box.firstChild);
        }
    }

    function grind() {
        const baseDmg = Math.floor(Math.random() * 15) + 5;
        const dmg = Math.max(1, baseDmg - Math.floor(p.wis / 3));
        
        p.hp = Math.max(0, p.hp - dmg);
        
        if (p.hp === 0) {
            addLog("<span style='color:red'>üíÄ YOU DIED üíÄ</span>");
            p.hp = p.mhp;
            p.gold = Math.floor(p.gold * 0.7);
            refreshUI();
            save();
            return;
        }
        
        const baseLoot = Math.floor(Math.random() * 20) + 10;
        const gainGold = Math.floor(baseLoot * (1 + p.lvl * 0.2));
        const gainXp = Math.floor(30 + p.lvl * 10);
        
        p.gold += gainGold;
        p.xp += gainXp;
        
        const xpNeeded = p.lvl * 100;
        if (p.xp >= xpNeeded) {
            p.lvl++;
            p.xp = 0;
            p.mhp += 25;
            p.hp = p.mhp;
            p.str += 2;
            addLog("<b style='color:lime'>‚ö° LEVEL UP! ‚ö°</b>");
        }
        
        addLog(`Slayed Beast. <span style='color:gold'>+${gainGold}g</span> | +${gainXp}xp | <span style='color:red'>-${dmg}hp</span>`);
        refreshUI();
        save();
    }

    function rest() {
        p.hp = p.mhp;
        refreshUI();
        save();
        addLog("<span style='color:cyan'>‚ú® Fully healed.</span>");
    }

    function refreshUI() {
        document.getElementById('s-lvl').innerText = p.lvl;
        document.getElementById('s-hp').innerText = `${Math.floor(p.hp)}/${p.mhp}`;
        document.getElementById('s-gold').innerText = p.gold;
        if (currentUser) {
            document.getElementById('s-name').innerText = `${p.avatar || 'üíÄ'} ${currentUser}`;
        }
    }

    function spawnBoss() {
        gameState.gate = 'OPEN';
        saveGameState();
        updateGateUI('OPEN');
        broadcastToMesh({ type: 'GATE_UPDATE', state: 'OPEN' });
        broadcastToTabs('GATE_UPDATE', 'OPEN');
        sendSystemChat("üåÄ THE VOID MASTER HAS OPENED THE GATE! üåÄ");
        addLog("<span style='color:var(--admin)'>Gate OPENED</span>");
    }

    function closeBoss() {
        gameState.gate = 'CLOSED';
        saveGameState();
        updateGateUI('CLOSED');
        broadcastToMesh({ type: 'GATE_UPDATE', state: 'CLOSED' });
        broadcastToTabs('GATE_UPDATE', 'CLOSED');
        sendSystemChat("üåÄ THE VOID MASTER HAS CLOSED THE GATE! üåÄ");
        addLog("<span style='color:var(--admin)'>Gate CLOSED</span>");
    }

    function loadLeaderboard() {
        updateLeaderboardDisplay();
    }

    function updateLeaderboardDisplay() {
        const list = document.getElementById('leaderboard-list');
        const debug = document.getElementById('lb-debug');
        
        const players = Object.values(gameState.players);
        debug.innerText = `${players.length} player(s) in realm`;
        updatePlayerCount();
        
        if (players.length === 0) {
            list.innerHTML = '<div style="color:#666;">No players yet...</div>';
            return;
        }
        
        const sorted = players.sort((a, b) => {
            if (b.lvl !== a.lvl) return b.lvl - a.lvl;
            return b.gold - a.gold;
        });
        
        list.innerHTML = sorted.map((pl, i) => {
            const isAdmin = pl.name === ADMIN ? '<span style="color:var(--admin)">(Void Master)</span>' : '';
            const isYou = pl.name === currentUser ? '<span style="color:var(--gold)"> ‚Üê YOU</span>' : '';
            const online = (Date.now() - pl.lastSeen < 6000) ? 'üü¢' : '‚ö´';
            const plGuild = getPlayerGuild(pl.name);
            const guildTag = plGuild ? `<span style="color:var(--gold);">[${plGuild}]</span> ` : '';
            return `<div style="padding:8px; border-bottom:1px solid #222;">
                ${online} ${i+1}. ${guildTag}${nameLink(pl.name)} ${isAdmin}${isYou} - Lvl ${pl.lvl} | ${pl.gold}g | ${pl.race}
            </div>`;
        }).join("");
        
        const myRank = sorted.findIndex(pl => pl.name === currentUser) + 1;
        document.getElementById('my-rank').innerText = myRank > 0 
            ? `‚öîÔ∏è YOUR RANK: #${myRank} of ${sorted.length}` 
            : 'Not ranked yet';
    }

    function refreshShop() {
        const cont = document.getElementById('shop-items');
        cont.innerHTML = "";
        const rarities = [
            {n:'Common', m:1},
            {n:'Rare', m:3},
            {n:'Epic', m:5},
            {n:'Legendary', m:10}
        ];
        
        rarities.forEach(r => {
            const cost = Math.floor(p.lvl * 100 * r.m);
            const power = Math.floor(p.lvl * 5 * r.m);
            const name = `${r.n} Artifact`;
            
            cont.innerHTML += `<div class="card" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <span><b>[${r.n}]</b> ${name} <span style="color:lime">(+${power} STR)</span></span>
                <button class="action-btn" onclick="buy(${cost}, ${power}, '${name}')">${cost}g</button>
            </div>`;
        });
    }

    function buy(c, pw, n) {
        if(p.gold >= c) {
            p.gold -= c;
            p.str += pw;
            p.weap = n;
            addLog(`<span style='color:lime'>Purchased: ${n}</span>`);
            refreshUI();
            save();
            refreshShop();
        } else {
            addLog("<span style='color:red'>Not enough gold!</span>");
        }
    }

    function fightBoss() {
        if (p.hp < 50) {
            addLog("<span style='color:red'>You need at least 50 HP!</span>");
            return;
        }
        
        const dmg = Math.floor(Math.random() * 30) + 20;
        const reward = Math.floor(p.lvl * 50) + 100;
        
        p.hp = Math.max(0, p.hp - dmg);
        p.gold += reward;
        p.xp += 200;
        
        addLog(`<span style='color:var(--admin)'>‚ö° Battled Horror! +${reward}g, +200xp | -${dmg}hp</span>`);
        
        refreshUI();
        save();
    }

    // ‚îÄ‚îÄ‚îÄ GUILD SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function getMyGuild() {
        if (!p.guild || !gameState.guilds) return null;
        return gameState.guilds[p.guild] || null;
    }

    function getPlayerGuild(playerName) {
        if (!gameState.guilds) return null;
        for (const [name, guild] of Object.entries(gameState.guilds)) {
            if (guild.members.includes(playerName)) return name;
        }
        return null;
    }

    function syncGuilds() {
        saveGameState();
        broadcastToMesh({ type: 'GUILD_UPDATE', guilds: gameState.guilds });
        broadcastToTabs('GUILD_UPDATE', gameState.guilds);
    }

    function syncWars() {
        saveGameState();
        broadcastToMesh({ type: 'WAR_UPDATE', wars: gameState.wars });
        broadcastToTabs('WAR_UPDATE', gameState.wars);
    }

    function createGuild() {
        const name = document.getElementById('guild-create-name').value.trim();
        if (!name || name.length < 2 || name.length > 24) {
            addLog("<span style='color:red'>Guild name must be 2-24 characters.</span>");
            return;
        }
        if (p.gold < 500) {
            addLog("<span style='color:red'>Not enough gold! Need 500g to found a guild.</span>");
            return;
        }
        if (p.guild) {
            addLog("<span style='color:red'>Leave your current guild first!</span>");
            return;
        }
        if (!gameState.guilds) gameState.guilds = {};
        if (gameState.guilds[name]) {
            addLog("<span style='color:red'>A guild with that name already exists!</span>");
            return;
        }

        p.gold -= 500;
        p.guild = name;

        gameState.guilds[name] = {
            leader: currentUser,
            members: [currentUser],
            created: Date.now()
        };

        refreshUI();
        save();
        syncGuilds();
        refreshGuildUI();
        addLog(`<span style='color:var(--gold)'>‚öîÔ∏è Founded guild: ${name}</span>`);
        sendSystemChat(`${currentUser} has founded the guild [${name}]!`);
    }

    function joinGuild(guildName) {
        if (p.guild) {
            addLog("<span style='color:red'>Leave your current guild first!</span>");
            return;
        }
        const guild = gameState.guilds[guildName];
        if (!guild) return;

        p.guild = guildName;
        guild.members.push(currentUser);

        save();
        syncGuilds();
        refreshGuildUI();
        addLog(`<span style='color:var(--gold)'>Joined guild: ${guildName}</span>`);
    }

    function leaveGuild() {
        if (!p.guild) return;
        const guild = gameState.guilds[p.guild];
        if (!guild) { p.guild = null; save(); return; }

        // If leader leaves, transfer or disband
        if (guild.leader === currentUser) {
            if (guild.members.length > 1) {
                guild.members = guild.members.filter(m => m !== currentUser);
                guild.leader = guild.members[0];
                addLog(`<span style='color:#888'>Leadership passed to ${guild.leader}.</span>`);
            } else {
                // Last member ‚Äî disband
                endAllWarsForGuild(p.guild);
                delete gameState.guilds[p.guild];
                addLog("<span style='color:#888'>Guild disbanded (no members left).</span>");
            }
        } else {
            guild.members = guild.members.filter(m => m !== currentUser);
        }

        p.guild = null;
        save();
        syncGuilds();
        refreshGuildUI();
    }

    function disbandGuild() {
        if (!p.guild) return;
        const guild = gameState.guilds[p.guild];
        if (!guild || guild.leader !== currentUser) {
            addLog("<span style='color:red'>Only the leader can disband!</span>");
            return;
        }

        if (!confirm(`Disband [${p.guild}]? This cannot be undone.`)) return;

        const guildName = p.guild;

        // Clear guild from all members in game state
        guild.members.forEach(member => {
            if (gameState.players[member]) {
                gameState.players[member].guild = null;
            }
        });

        endAllWarsForGuild(guildName);
        delete gameState.guilds[guildName];
        p.guild = null;

        save();
        syncGuilds();
        syncWars();
        refreshGuildUI();
        addLog(`<span style='color:red'>Guild [${guildName}] has been disbanded.</span>`);
        sendSystemChat(`The guild [${guildName}] has been disbanded!`);
    }

    // ‚îÄ‚îÄ‚îÄ WAR SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    const WAR_GOAL = 10; // First to 10 kills wins

    function getActiveWar(guild1, guild2) {
        if (!gameState.wars) return null;
        return gameState.wars.find(w => 
            !w.ended && 
            ((w.attacker === guild1 && w.defender === guild2) || 
             (w.attacker === guild2 && w.defender === guild1))
        );
    }

    function getActiveWarsForGuild(guildName) {
        if (!gameState.wars) return [];
        return gameState.wars.filter(w => !w.ended && (w.attacker === guildName || w.defender === guildName));
    }

    function declareWar(targetGuild) {
        if (!p.guild) return;
        const myGuild = getMyGuild();
        if (!myGuild || myGuild.leader !== currentUser) {
            addLog("<span style='color:red'>Only the guild leader can declare war!</span>");
            return;
        }
        if (p.guild === targetGuild) return;

        const existing = getActiveWar(p.guild, targetGuild);
        if (existing) {
            addLog("<span style='color:red'>Already at war with that guild!</span>");
            return;
        }

        if (!gameState.wars) gameState.wars = [];

        const war = {
            id: 'war_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6),
            attacker: p.guild,
            defender: targetGuild,
            scores: { att: 0, def: 0 },
            goal: WAR_GOAL,
            started: Date.now(),
            ended: null,
            winner: null
        };

        gameState.wars.push(war);
        syncWars();
        refreshGuildUI();
        addLog(`<span style='color:#ff8800'>‚öîÔ∏è Declared war on [${targetGuild}]! First to ${WAR_GOAL} kills wins!</span>`);
        sendSystemChat(`[${p.guild}] has declared WAR on [${targetGuild}]! ‚öîÔ∏è`);
    }

    function scoreWarKill(winnerGuild, loserGuild) {
        if (!gameState.wars) return;
        const war = getActiveWar(winnerGuild, loserGuild);
        if (!war) return;

        // Figure out which side scored
        if (war.attacker === winnerGuild) {
            war.scores.att++;
        } else {
            war.scores.def++;
        }

        // Check for war end
        if (war.scores.att >= war.goal) {
            war.ended = Date.now();
            war.winner = war.attacker;
            sendSystemChat(`‚öîÔ∏è [${war.attacker}] has WON the war against [${war.defender}]! (${war.scores.att}-${war.scores.def})`);
        } else if (war.scores.def >= war.goal) {
            war.ended = Date.now();
            war.winner = war.defender;
            sendSystemChat(`‚öîÔ∏è [${war.defender}] has WON the war against [${war.attacker}]! (${war.scores.def}-${war.scores.att})`);
        }

        syncWars();
    }

    function endAllWarsForGuild(guildName) {
        if (!gameState.wars) return;
        gameState.wars.forEach(war => {
            if (!war.ended && (war.attacker === guildName || war.defender === guildName)) {
                war.ended = Date.now();
                war.winner = war.attacker === guildName ? war.defender : war.attacker;
            }
        });
    }

    function refreshGuildUI() {
        if (!gameState.guilds) gameState.guilds = {};
        if (!gameState.wars) gameState.wars = [];

        const noGuildEl = document.getElementById('guild-no-guild');
        const myGuildEl = document.getElementById('guild-my-guild');
        const warHint = document.getElementById('war-bonus-hint');

        if (!p.guild || !gameState.guilds[p.guild]) {
            // Not in a guild
            noGuildEl.classList.remove('hidden');
            myGuildEl.classList.add('hidden');
            if (warHint) warHint.style.display = 'none';
            
            // Show available guilds
            const listEl = document.getElementById('guild-available-list');
            const guilds = Object.entries(gameState.guilds);
            if (guilds.length === 0) {
                listEl.innerHTML = '<span style="color:#666;">No guilds exist yet. Be the first!</span>';
            } else {
                listEl.innerHTML = guilds.map(([name, g]) => {
                    return `<div class="card" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding:12px;">
                        <div>
                            <b style="color:var(--gold);">[${name}]</b><br>
                            <span style="font-size:0.8rem; color:#888;">Leader: ${g.leader} ¬∑ ${g.members.length} member(s)</span>
                        </div>
                        <button class="action-btn" onclick="joinGuild('${name.replace(/'/g, "\\'")}')">Join</button>
                    </div>`;
                }).join('');
            }
            return;
        }

        // In a guild
        noGuildEl.classList.add('hidden');
        myGuildEl.classList.remove('hidden');

        const guild = gameState.guilds[p.guild];
        document.getElementById('guild-name-display').innerText = `[${p.guild}]`;

        // Leader controls
        const leaderCtrl = document.getElementById('guild-leader-controls');
        const warCtrl = document.getElementById('guild-war-controls');
        if (guild.leader === currentUser) {
            leaderCtrl.classList.remove('hidden');
            warCtrl.classList.remove('hidden');
        } else {
            leaderCtrl.classList.add('hidden');
            warCtrl.classList.add('hidden');
        }

        // Members
        const memberList = document.getElementById('guild-member-list');
        memberList.innerHTML = guild.members.map(name => {
            const pl = gameState.players[name];
            const isLeader = name === guild.leader ? ' üëë' : '';
            const online = pl && (Date.now() - pl.lastSeen < 6000) ? 'üü¢' : '‚ö´';
            const lvl = pl ? `Lvl ${pl.lvl}` : '???';
            return `<div style="padding:6px 0; border-bottom:1px solid #1a1a1a;">
                ${online} ${nameLink(name)}${isLeader} ‚Äî ${lvl}
            </div>`;
        }).join('');

        // War targets (other guilds to declare war on)
        if (guild.leader === currentUser) {
            const warTargetList = document.getElementById('guild-war-target-list');
            const otherGuilds = Object.entries(gameState.guilds).filter(([name]) => name !== p.guild);
            if (otherGuilds.length === 0) {
                warTargetList.innerHTML = '<span style="color:#666;">No other guilds to challenge.</span>';
            } else {
                warTargetList.innerHTML = otherGuilds.map(([name, g]) => {
                    const atWar = getActiveWar(p.guild, name);
                    if (atWar) {
                        return `<div style="padding:6px 0; color:#ff8800;">‚öîÔ∏è [${name}] ‚Äî Already at war</div>`;
                    }
                    return `<div class="card" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; padding:10px;">
                        <span><b style="color:var(--gold);">[${name}]</b> ¬∑ ${g.members.length} member(s)</span>
                        <button class="action-btn" style="border-color:#ff8800;" onclick="declareWar('${name.replace(/'/g, "\\'")}')">‚öîÔ∏è Declare War</button>
                    </div>`;
                }).join('');
            }
        }

        // Active wars
        const activeWars = getActiveWarsForGuild(p.guild);
        const activeEl = document.getElementById('guild-active-wars');
        if (activeWars.length === 0) {
            activeEl.innerHTML = '<span style="color:#666;">No active wars</span>';
            if (warHint) warHint.style.display = 'none';
        } else {
            if (warHint) warHint.style.display = 'inline';
            activeEl.innerHTML = activeWars.map(war => {
                const isAttacker = war.attacker === p.guild;
                const enemy = isAttacker ? war.defender : war.attacker;
                const myScore = isAttacker ? war.scores.att : war.scores.def;
                const theirScore = isAttacker ? war.scores.def : war.scores.att;
                const elapsed = Math.floor((Date.now() - war.started) / 60000);
                const timeStr = elapsed < 60 ? `${elapsed}m` : `${Math.floor(elapsed/60)}h ${elapsed%60}m`;
                return `<div class="card" style="border-color:#ff8800; padding:12px; margin-bottom:8px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <div>
                            <b style="color:#ff8800;">‚öîÔ∏è vs [${enemy}]</b><br>
                            <span style="font-size:0.8rem; color:#888;">First to ${war.goal} ¬∑ ${timeStr} elapsed</span>
                        </div>
                        <div style="text-align:center;">
                            <span style="font-size:1.4rem; color:var(--gold); font-weight:bold;">${myScore}</span>
                            <span style="color:#666;"> ‚Äî </span>
                            <span style="font-size:1.4rem; color:#cc4444; font-weight:bold;">${theirScore}</span>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }

        // War history
        const pastWars = (gameState.wars || []).filter(w => w.ended && (w.attacker === p.guild || w.defender === p.guild));
        const historyEl = document.getElementById('guild-war-history');
        if (pastWars.length === 0) {
            historyEl.innerHTML = '<span style="color:#666;">No past wars</span>';
        } else {
            historyEl.innerHTML = pastWars.slice(-10).reverse().map(war => {
                const isAttacker = war.attacker === p.guild;
                const enemy = isAttacker ? war.defender : war.attacker;
                const myScore = isAttacker ? war.scores.att : war.scores.def;
                const theirScore = isAttacker ? war.scores.def : war.scores.att;
                const won = war.winner === p.guild;
                const dateStr = new Date(war.ended).toLocaleDateString();
                return `<div style="padding:6px 0; border-bottom:1px solid #1a1a1a;">
                    <span style="color:${won ? '#44ff44' : '#ff4444'};">${won ? '‚úÖ WON' : '‚ùå LOST'}</span> 
                    vs [${enemy}] ‚Äî ${myScore}:${theirScore} ¬∑ ${dateStr}
                </div>`;
            }).join('');
        }
    }

    // ‚îÄ‚îÄ‚îÄ PROFILE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    const AVATARS = [
        'üíÄ','üëª','üêâ','üßô','‚öîÔ∏è','üó°Ô∏è','üõ°Ô∏è','üëπ','ü¶á','üê∫',
        'üî•','‚ùÑÔ∏è','‚ö°','üåë','‚ò†Ô∏è','üï∑Ô∏è','üêç','ü¶Ö','üëÅÔ∏è','üé≠',
        'üßõ','üßü','üë∫','ü§ñ','ü¶ä','üêª','ü¶Å','üê≤','üíé','üåÄ'
    ];

    function nameLink(name) {
        if (!name || name === 'SYSTEM') return `<b>${name || '???'}</b>`;
        const escaped = name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        const pl = gameState.players[name];
        const av = pl && pl.avatar ? pl.avatar : 'üíÄ';
        return `<span class="name-link" onclick="viewProfile('${escaped}')">${av} <b>${name}</b></span>`;
    }

    function viewProfile(playerName) {
        const pl = gameState.players[playerName];
        const cont = document.getElementById('profile-content');
        
        if (!pl) {
            cont.innerHTML = `<div class="card"><h3>Player Not Found</h3><p style="color:#666;">No data for "${playerName}".</p></div>`;
            showTab('profile');
            return;
        }

        const isMe = pl.name === currentUser;
        const isAdmin = pl.name === ADMIN;
        const online = (Date.now() - pl.lastSeen < 6000) ? '<span style="color:#0f0;">‚óè Online</span>' : '<span style="color:#666;">‚óè Offline</span>';
        const plGuild = getPlayerGuild(pl.name);
        const guildDisplay = plGuild ? `<span style="color:var(--gold);">[${plGuild}]</span>` : '<span style="color:#666;">No guild</span>';
        const adminBadge = isAdmin ? ' <span style="color:var(--admin);">‚òÖ Void Master</span>' : '';
        const blurb = pl.blurb || '<span style="color:#555; font-style:italic;">No blurb set.</span>';
        const avatar = pl.avatar || 'üíÄ';

        // Equipment display
        const weapDisplay = pl.weap && pl.weap !== 'None' 
            ? `<span style="color:lime;">‚öî ${pl.weap}</span>` 
            : '<span style="color:#555;">None</span>';

        // Stat bars
        const hpPercent = Math.floor((pl.hp / pl.mhp) * 100);
        const hpColor = hpPercent > 60 ? '#0f0' : hpPercent > 30 ? '#ff0' : '#f00';

        // War record
        let warWins = 0, warLosses = 0;
        if (plGuild && gameState.wars) {
            gameState.wars.filter(w => w.ended).forEach(w => {
                if (w.attacker === plGuild || w.defender === plGuild) {
                    if (w.winner === plGuild) warWins++;
                    else warLosses++;
                }
            });
        }

        const lastSeenStr = new Date(pl.lastSeen).toLocaleString();

        // ‚îÄ‚îÄ‚îÄ Own-profile editable sections ‚îÄ‚îÄ‚îÄ
        let blurbSection;
        if (isMe) {
            blurbSection = `
                <div style="margin-top:15px;">
                    <label style="color:#888; font-size:0.8rem; text-transform:uppercase; letter-spacing:1px;">Your Blurb</label>
                    <textarea id="profile-blurb-input" style="width:100%; height:60px; background:#111; border:1px solid #333; color:white; padding:10px; font-family:inherit; resize:vertical; box-sizing:border-box;" maxlength="200">${p.blurb || ''}</textarea>
                    <button class="action-btn" onclick="saveBlurb()" style="margin-top:5px;">Save Blurb</button>
                    <span style="font-size:0.75rem; color:#555; margin-left:10px;">Max 200 characters</span>
                </div>`;
        } else {
            blurbSection = `<div style="margin:15px 0; padding:15px; background:#111; border-left:3px solid var(--gold); font-style:italic; color:#ccc;">${blurb}</div>`;
        }

        let avatarSection = '';
        if (isMe) {
            const avatarGrid = AVATARS.map(av => {
                const selected = av === p.avatar;
                return `<span onclick="selectAvatar('${av}')" style="font-size:1.6rem; cursor:pointer; padding:6px; border:2px solid ${selected ? 'var(--gold)' : 'transparent'}; border-radius:6px; display:inline-block; transition:0.15s; ${selected ? 'background:rgba(212,175,55,0.15);' : ''}" onmouseover="this.style.borderColor='#555'" onmouseout="this.style.borderColor='${selected ? 'var(--gold)' : 'transparent'}'">${av}</span>`;
            }).join('');
            avatarSection = `
            <div class="card">
                <h3 style="color:var(--accent); margin-top:0;">Choose Avatar</h3>
                <div style="line-height:2.5;">${avatarGrid}</div>
            </div>`;
        }

        let passwordSection = '';
        if (isMe) {
            passwordSection = `
            <div class="card">
                <h3 style="color:var(--accent); margin-top:0;">Change Password</h3>
                <div style="display:flex; flex-direction:column; gap:8px; max-width:300px;">
                    <input type="password" id="profile-old-pw" placeholder="Current password" style="width:100%;">
                    <input type="password" id="profile-new-pw" placeholder="New password" style="width:100%;">
                    <input type="password" id="profile-new-pw2" placeholder="Confirm new password" style="width:100%;">
                    <button class="action-btn" onclick="changePassword()" style="margin-top:5px;">Update Password</button>
                    <div id="pw-change-msg" style="font-size:0.85rem; min-height:1.2em;"></div>
                </div>
            </div>`;
        }

        cont.innerHTML = `
            <div class="card">
                <div style="display:flex; justify-content:space-between; align-items:flex-start;">
                    <div style="display:flex; gap:15px; align-items:center;">
                        <div style="font-size:3.5rem; width:70px; height:70px; display:flex; align-items:center; justify-content:center; background:#111; border:2px solid #333; border-radius:10px;">${avatar}</div>
                        <div>
                            <h2 style="color:var(--accent); margin:0 0 5px 0;">${pl.name}${adminBadge}</h2>
                            <div style="font-size:0.9rem; margin-bottom:3px;">${online} ¬∑ ${pl.race} ¬∑ ${guildDisplay}</div>
                            <div style="font-size:0.8rem; color:#555;">Last seen: ${lastSeenStr}</div>
                        </div>
                    </div>
                    <div style="text-align:right;">
                        <div style="font-size:2rem; color:var(--gold); font-weight:bold;">Lv.${pl.lvl}</div>
                    </div>
                </div>
                ${blurbSection}
            </div>

            <div class="card">
                <h3 style="color:var(--accent); margin-top:0;">Stats</h3>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
                    <div>
                        <div style="color:#888; font-size:0.8rem; text-transform:uppercase;">HP</div>
                        <div style="background:#222; height:20px; margin-top:4px; position:relative;">
                            <div style="background:${hpColor}; height:100%; width:${hpPercent}%; transition:0.3s;"></div>
                            <span style="position:absolute; top:2px; left:8px; font-size:0.75rem; color:#fff;">${Math.floor(pl.hp)} / ${pl.mhp}</span>
                        </div>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8rem; text-transform:uppercase;">Gold</div>
                        <div style="color:var(--gold); font-size:1.2rem; font-weight:bold;">${pl.gold}g</div>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8rem; text-transform:uppercase;">Strength</div>
                        <div style="color:#ff6666; font-size:1.2rem; font-weight:bold;">${pl.str}</div>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8rem; text-transform:uppercase;">Wisdom</div>
                        <div style="color:#6666ff; font-size:1.2rem; font-weight:bold;">${pl.wis}</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3 style="color:var(--accent); margin-top:0;">Equipment</h3>
                <div style="padding:10px; background:#111; border:1px solid #222;">
                    <div style="color:#888; font-size:0.8rem; text-transform:uppercase; margin-bottom:5px;">Weapon</div>
                    <div style="font-size:1.1rem;">${weapDisplay}</div>
                </div>
            </div>

            ${plGuild ? `
            <div class="card">
                <h3 style="color:var(--accent); margin-top:0;">Guild</h3>
                <div style="font-size:1.1rem; color:var(--gold); margin-bottom:5px;">[${plGuild}]</div>
                <div style="color:#888; font-size:0.85rem;">War Record: <span style="color:#0f0;">${warWins}W</span> / <span style="color:#f00;">${warLosses}L</span></div>
            </div>` : ''}

            ${avatarSection}
            ${passwordSection}

            ${!isMe ? `
            <div class="card" style="text-align:center;">
                <button class="action-btn" style="border-color:#cc4444;" onclick="showTab('pvp'); refreshPvpTargets();">‚öîÔ∏è Fight in Arena</button>
            </div>` : ''}
        `;

        showTab('profile');
    }

    function saveBlurb() {
        const input = document.getElementById('profile-blurb-input');
        if (!input) return;
        p.blurb = input.value.trim().substring(0, 200);
        save();
        addLog("<span style='color:var(--gold)'>Blurb updated!</span>");
    }

    function selectAvatar(av) {
        p.avatar = av;
        save();
        // Re-render profile to show selection
        viewProfile(currentUser);
        addLog(`<span style='color:var(--gold)'>Avatar changed to ${av}</span>`);
    }

    async function changePassword() {
        const oldPw = document.getElementById('profile-old-pw').value;
        const newPw = document.getElementById('profile-new-pw').value;
        const newPw2 = document.getElementById('profile-new-pw2').value;
        const msgEl = document.getElementById('pw-change-msg');
        
        msgEl.style.color = '#ff4444';
        
        if (!oldPw || !newPw || !newPw2) {
            msgEl.innerText = 'Please fill in all fields.';
            return;
        }
        if (newPw.length < 4) {
            msgEl.innerText = 'New password must be at least 4 characters.';
            return;
        }
        if (newPw !== newPw2) {
            msgEl.innerText = 'New passwords do not match.';
            return;
        }

        const accounts = getAccounts();
        const account = accounts[currentUser.toLowerCase()];
        if (!account) {
            msgEl.innerText = 'Account error.';
            return;
        }

        const oldHash = await hashPassword(oldPw);
        if (oldHash !== account.hash) {
            msgEl.innerText = 'Current password is incorrect.';
            return;
        }

        account.hash = await hashPassword(newPw);
        saveAccounts(accounts);
        broadcastToMesh({ type: 'ACCOUNT_SYNC', accounts: accounts });

        msgEl.style.color = '#44ff44';
        msgEl.innerText = 'Password changed successfully!';
        document.getElementById('profile-old-pw').value = '';
        document.getElementById('profile-new-pw').value = '';
        document.getElementById('profile-new-pw2').value = '';
    }

    // ‚îÄ‚îÄ‚îÄ PVP ARENA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    let pvpCooldowns = {}; // { targetName: timestamp }
    const PVP_COOLDOWN_MS = 60000; // 1 minute cooldown per target

    function refreshPvpTargets() {
        const cont = document.getElementById('pvp-targets');
        const players = Object.values(gameState.players).filter(pl => pl.name !== currentUser);
        
        if (players.length === 0) {
            cont.innerHTML = '<div style="color:#666;">No other players in the realm...</div>';
            return;
        }

        const sorted = players.sort((a, b) => a.lvl - b.lvl);
        
        cont.innerHTML = sorted.map(pl => {
            const lvlDiff = pl.lvl - p.lvl;
            const diffLabel = lvlDiff > 0 ? `<span style="color:#ff6666;">+${lvlDiff} above you</span>` 
                            : lvlDiff < 0 ? `<span style="color:#66ff66;">${lvlDiff} below you</span>`
                            : `<span style="color:#aaa;">same level</span>`;
            const online = (Date.now() - pl.lastSeen < 6000) ? 'üü¢' : '‚ö´';
            const onCooldown = pvpCooldowns[pl.name] && (Date.now() - pvpCooldowns[pl.name] < PVP_COOLDOWN_MS);
            const cdLeft = onCooldown ? Math.ceil((PVP_COOLDOWN_MS - (Date.now() - pvpCooldowns[pl.name])) / 1000) : 0;
            
            // Guild tag and war indicator
            const plGuild = getPlayerGuild(pl.name);
            const guildTag = plGuild ? `<span style="color:var(--gold);">[${plGuild}]</span> ` : '';
            const atWar = plGuild && p.guild && getActiveWar(p.guild, plGuild);
            const warTag = atWar ? `<span style="color:#ff8800; font-size:0.8rem;"> ‚öîÔ∏è AT WAR</span>` : '';
            
            const btnHtml = onCooldown 
                ? `<button class="action-btn" disabled style="opacity:0.4; cursor:not-allowed;">${cdLeft}s</button>`
                : `<button class="action-btn" style="border-color:${atWar ? '#ff8800' : '#cc4444'};" onclick="pvpAttack('${pl.name}')">${atWar ? '‚öîÔ∏è War Attack' : '‚öîÔ∏è Attack'}</button>`;
            
            return `<div class="card" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; padding:15px; ${atWar ? 'border-color:#ff8800;' : ''}">
                <div>
                    ${online} ${guildTag}${nameLink(pl.name)}${warTag} ‚Äî Lvl ${pl.lvl} | ${pl.gold}g | STR ${pl.str} | WIS ${pl.wis}<br>
                    <span style="font-size:0.8rem;">${diffLabel} ¬∑ ${pl.race}</span>
                </div>
                ${btnHtml}
            </div>`;
        }).join("");
    }

    function pvpAttack(targetName) {
        // Cooldown check
        if (pvpCooldowns[targetName] && (Date.now() - pvpCooldowns[targetName] < PVP_COOLDOWN_MS)) {
            addLog("<span style='color:red'>That target is still recovering. Wait a moment.</span>");
            return;
        }

        const target = gameState.players[targetName];
        if (!target) {
            addLog("<span style='color:red'>Target not found!</span>");
            return;
        }

        if (p.hp < 20) {
            addLog("<span style='color:red'>You need at least 20 HP to fight in the arena!</span>");
            return;
        }

        // Combat calculation
        // Attacker power: str + (lvl * 3) + random factor
        // Defender power: str + wis + (lvl * 2) + random factor (defender gets wis bonus)
        const attackRoll = p.str + (p.lvl * 3) + Math.floor(Math.random() * 20);
        const defendRoll = target.str + target.wis + (target.lvl * 2) + Math.floor(Math.random() * 20);
        
        const won = attackRoll > defendRoll;
        const lvlDiff = target.lvl - p.lvl;
        
        // Combat damage to attacker regardless of outcome
        const selfDmg = Math.floor(Math.random() * 10) + 5;
        p.hp = Math.max(1, p.hp - selfDmg);

        let goldStolen = 0;
        let xpGained = 0;
        let resultMsg = '';

        if (won) {
            // Steal 5-15% of target's gold
            const stealPercent = (Math.random() * 0.10) + 0.05;
            goldStolen = Math.max(1, Math.floor(target.gold * stealPercent));
            
            // XP scales with level difference (more for higher level targets)
            const baseXp = 50;
            const bonusXp = Math.max(0, lvlDiff) * 30;
            xpGained = baseXp + bonusXp;

            p.gold += goldStolen;
            p.xp += xpGained;
            
            // Deduct gold from target in game state
            gameState.players[targetName].gold = Math.max(0, target.gold - goldStolen);

            // Check level up
            const xpNeeded = p.lvl * 100;
            if (p.xp >= xpNeeded) {
                p.lvl++;
                p.xp = 0;
                p.mhp += 25;
                p.hp = p.mhp;
                p.str += 2;
                addLog("<b style='color:lime'>‚ö° LEVEL UP! ‚ö°</b>");
            }

            resultMsg = `‚öîÔ∏è VICTORY vs ${targetName}! Stole ${goldStolen}g, earned ${xpGained}xp (-${selfDmg}hp)`;
            addPvpLog(`<span style="color:#44ff44;">‚öîÔ∏è You defeated ${targetName}! +${goldStolen}g, +${xpGained}xp</span>`);

            // Guild war scoring
            const myGuildName = p.guild;
            const targetGuildName = getPlayerGuild(targetName);
            if (myGuildName && targetGuildName && myGuildName !== targetGuildName) {
                const war = getActiveWar(myGuildName, targetGuildName);
                if (war) {
                    scoreWarKill(myGuildName, targetGuildName);
                    addPvpLog(`<span style="color:#ff8800;">‚öîÔ∏è +1 WAR POINT for [${myGuildName}]!</span>`);
                }
            }
        } else {
            // Lost ‚Äî lose a small amount of gold
            const lostGold = Math.max(1, Math.floor(p.gold * 0.03));
            p.gold = Math.max(0, p.gold - lostGold);
            
            resultMsg = `üíÄ DEFEATED by ${targetName}! Lost ${lostGold}g (-${selfDmg}hp)`;
            addPvpLog(`<span style="color:#ff4444;">üíÄ You were defeated by ${targetName}. Lost ${lostGold}g</span>`);

            // Guild war scoring for defender's guild
            const myGuildName2 = p.guild;
            const targetGuildName2 = getPlayerGuild(targetName);
            if (myGuildName2 && targetGuildName2 && myGuildName2 !== targetGuildName2) {
                const war2 = getActiveWar(myGuildName2, targetGuildName2);
                if (war2) {
                    scoreWarKill(targetGuildName2, myGuildName2);
                    addPvpLog(`<span style="color:#ff8800;">‚öîÔ∏è +1 WAR POINT for [${targetGuildName2}]...</span>`);
                }
            }
        }

        addLog(`<span style='color:#cc4444;'>${resultMsg}</span>`);
        
        // Set cooldown
        pvpCooldowns[targetName] = Date.now();

        // Save attacker state
        refreshUI();
        save();
        saveGameState();

        // Notify the target via mesh
        const attackResult = {
            type: 'PVP_ATTACK',
            attacker: currentUser,
            target: targetName,
            won: won,
            goldStolen: goldStolen,
            xpGained: xpGained,
            timestamp: Date.now()
        };
        
        broadcastToMesh(attackResult);
        broadcastToTabs('PVP_ATTACK', attackResult);

        refreshPvpTargets();
    }

    function handlePvpNotification(data) {
        // Only show notification if we are the target
        if (data.target !== currentUser) return;

        let msg;
        if (data.won) {
            msg = `‚öîÔ∏è ${data.attacker} attacked you and stole ${data.goldStolen}g!`;
            addPvpLog(`<span style="color:#ff4444;">‚öîÔ∏è ${data.attacker} raided you and stole ${data.goldStolen}g!</span>`);
            
            // Update our local gold to reflect the theft
            p.gold = Math.max(0, p.gold - data.goldStolen);
            refreshUI();
            save();
        } else {
            msg = `üõ°Ô∏è ${data.attacker} attacked you but you defended successfully!`;
            addPvpLog(`<span style="color:#44ff44;">üõ°Ô∏è ${data.attacker} tried to raid you but failed!</span>`);
        }

        // Show notification banner
        const notifEl = document.getElementById('pvp-notification');
        document.getElementById('pvp-notif-text').innerText = msg;
        notifEl.style.display = 'flex';
    }

    function dismissNotification() {
        document.getElementById('pvp-notification').style.display = 'none';
    }

    function addPvpLog(html) {
        const log = document.getElementById('pvp-log');
        if (!log) return;
        const entry = document.createElement('div');
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<span style="color:#666;">${time}</span> ${html}`;
        entry.style.padding = '4px 0';
        entry.style.borderBottom = '1px solid #1a1a1a';
        log.insertBefore(entry, log.firstChild);
        
        while (log.children.length > 20) {
            log.removeChild(log.lastChild);
        }
    }

    // ‚îÄ‚îÄ‚îÄ CHAT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function sendChat() {
        const input = document.getElementById('chat-in');
        const text = input.value.trim();
        if (!text) return;
        
        const msg = {
            id: 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            from: currentUser,
            text: text,
            time: Date.now()
        };
        
        seenChatIds.add(msg.id);
        gameState.chat.push(msg);
        if (gameState.chat.length > 100) gameState.chat.shift();
        saveGameState();
        
        displayChat(msg);
        broadcastToMesh({ type: 'CHAT_MESSAGE', msg });
        broadcastToTabs('CHAT_MESSAGE', msg);
        
        input.value = "";
    }

    function sendSystemChat(text) {
        const msg = {
            id: 'sys_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            from: 'SYSTEM',
            text: text,
            time: Date.now()
        };
        
        seenChatIds.add(msg.id);
        gameState.chat.push(msg);
        if (gameState.chat.length > 100) gameState.chat.shift();
        saveGameState();
        
        displayChat(msg);
        broadcastToMesh({ type: 'CHAT_MESSAGE', msg });
        broadcastToTabs('CHAT_MESSAGE', msg);
    }

    function addLog(m) {
        const l = document.getElementById('game-log');
        const entry = document.createElement('div');
        entry.innerHTML = `> ${m}`;
        l.insertBefore(entry, l.firstChild);
        
        while(l.children.length > 12) {
            l.removeChild(l.lastChild);
        }
    }

    function showTab(id) {
        document.querySelectorAll('section').forEach(s => s.classList.add('hidden'));
        document.getElementById('tab-' + id).classList.remove('hidden');
    }
</script>
</body>
</html>